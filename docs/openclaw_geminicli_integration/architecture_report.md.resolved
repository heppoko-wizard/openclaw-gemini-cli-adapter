# OpenClawとGemini CLIの自律性アーキテクチャ比較および技術レポート

本レポートでは、OpenClawが持つ「プロンプトなしで自立稼働する力」の構造的な詳細と、現在のGemini CLIになぜそれが欠けているのか、そしてGemini CLIへネイティブまたはポータブルに移植するための具体的な考察をまとめます。

## 1. OpenClawの「自律稼働（Heartbeat）」の構造解析

コードベースの調査により、OpenClawの自律性は以下の3つの要素から構成されていることが分かりました。

### A. OS標準機能によるデーモン化 (プロセス永続性)
OpenClawの [src/cli/node-cli/daemon.ts](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/openclaw/src/cli/node-cli/daemon.ts) にあるように、内部固有のデーモンエンジンを持つわけではなく、**OSの標準機能（macOSの`launchctl`、Linuxの`systemd`、Windowsの`schtasks`）を利用してNode.jsプロセスをバックグラウンドに登録**しています。
プロセス自体は単なるNode.jsの常駐プログラムであり、OS側に再起動や死活監視を委ねる設計になっています。

### B. [HeartbeatRunner](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/openclaw/src/infra/heartbeat-runner.ts#117-121) による定期的トリガー
自律思考の心臓部となるのは [src/infra/heartbeat-runner.ts](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/openclaw/src/infra/heartbeat-runner.ts) の [runHeartbeatOnce](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/openclaw/src/infra/heartbeat-runner.ts#563-954) という関数です。
- これは設定された間隔（例：`every: "10m"`）に従い、タイマーまたはCronイベントによって定期的に呼び出されます。
- [HEARTBEAT.md](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/openclaw/docs/reference/templates/HEARTBEAT.md) （ワークスペース内のテンプレートファイル）を読み込み、ファイルが空でなければ発火条件を満たしたとみなします。

### C. 特殊なシステムプロンプトとコンテキストの差し込み
[runHeartbeatOnce](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/openclaw/src/infra/heartbeat-runner.ts#563-954) が実行されると、以下のような処理がGemini APIに渡されます。
1. `appendCronStyleCurrentTimeLine` を用いて、現在の時刻をプロンプトの末尾に動的に追加します。
2. ユーザーからの入力の代わりに、システムが [runHeartbeatOnce](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/openclaw/src/infra/heartbeat-runner.ts#563-954) の理由（cronタイマーや非同期関数の完了等）をまとめた特殊なプロンプトを作成します。
3. エージェントはツール（ファイル閲覧や検索）を自由に呼び出し、タスクを処理します。
4. 処理が終わると、モデルは暗黙の了解として（またはシステムプロンプトの指示通りに）`HEARTBEAT_OK` などの特殊なトークンを返し、それを検知して処理を終了し、次回のタイマーまで待機します。

## 2. Gemini CLIのAgent構造解析

一方、Gemini CLIのアーキテクチャ（[packages/core/src/agents/generalist-agent.ts](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/gemini-cli/packages/core/src/agents/generalist-agent.ts) や [agent-scheduler.ts](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/gemini-cli/packages/core/src/agents/agent-scheduler.ts)）は、「ユーザー起点からの対話的タスク解決」に最適化されています。

### A. リニアな実行モデル
Gemini CLIの Generalist Agent は、入力スキーマ (`request: string`) に応じてツールを駆使して回答を生成しますが、実行基盤には `maxTurns: 20` などの制限があり、タスクが完了すればプロセスは自然終了します。
自ら**「次いつ起きるか」をスケジュールしてプロセスを維持する仕組みが存在しません。**

### B. トリガーの不在
タスクを実行するための [ToolRegistry](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/gemini-cli/packages/core/src/agents/agent-scheduler.ts#58-59) や `Scheduler` は非常に強力ですが、これらはあくまで「プロンプトが与えられた後に、どの順番でツールを捌くか」を管理するものです。外部（カレンダー、時刻、ファイル更新）からのトリガーを待ち受けるイベントループを持っていません。

## 3. なぜ当初の「シェルスクリプト構成」では上っ面になるのか？

前回の実装計画（シェルスクリプトによるループ）は、以下の理由で「本質的な自律性」を取りこぼしてしまいます。

1. **コンテキストの切断**: 単一のシェルスクリプト(`run_cycle.sh`)による `gemini generate` コマンドラインの定期的発行は、毎回プロセスが破棄され、前回のメモリ（会話履歴や思考の文脈）が維持されません。OpenClawは同一プロセス内でセッションメモリを保持しているため、タスクの継続性が保たれます。
2. **非同期イベントの検知不足**: OpenClawは単なる定期実行だけでなく、「以前実行した非同期システムの完了(`exec-event`)」などもトリガーにできます。これをスクリプトで模倣するのは極めて困難です。

## 4. Gemini CLIへの移植アプローチ (技術的結論)

完全な再現を行うには、「Gemini CLIのNode.jsプロセスを常駐させ、内部的にイベントループを回す」必要があります。以下の2つのアプローチが考えられます。

### アプローチ1: Gemini CLIのTypeScriptソースへ直接改修を入れる (推奨)
1. `gemini-cli/packages/core/src` の下に、OpenClawの `heartbeat-runner.ts` 相当のタイマーイベントループ機能を移植する。
2. OSのデーモン管理機能 (`systemd` など) への登録処理を CLI のコマンド (`gemini daemon start` 等) として追加する。
3. Agentのランタイムが、ユーザープロンプトがなくても定期的に自分自身を呼び出し、`HEARTBEAT.md` のタスクを処理して会話履歴（Sessionファイル）に永続化できるようにする。

### アプローチ2: スクリプトによる「疑似常駐と履歴ファイル結合」 (応急処置)
Gemini CLIが標準で持つ「セッションファイル再開機能（`--session`）」をシェルスクリプトに組み込みます。
`gemini generate --session=daemon_session ...` のようにして呼ぶことで、プロセスは毎回破棄されても会話コンテキストだけは繋がるようにします。ただし、内部イベント(非同期の完了等)はフックできません。

---

**→ 結論:** 本格的な自立エージェント機能をGemini CLIに取り込む（再興する）には、**アプローチ1: Gemini CLI自体のTypescriptコードベースを拡張し、Heartbeat機構とDaemonコマンドをネイティブパッケージとして追加・ビルドすること**が必要です。
