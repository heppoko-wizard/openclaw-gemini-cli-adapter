# アダプタ構成によるGemini CLIとOpenClawの統合可能性と限界

「OpenClawがLLMを呼ぶ際のAPIリクエスト（ツールやパラメータを含む）をローカルでGemini CLIに横流しし、APIの差異やツールの不整合を吸収するアダプタ」というアプローチについての考察です。

## 1. ツールとスキルの「本質的な違い」とアダプタの役割分離

今回再調査した結果、LLMエージェントにおける「ツール（Tools）」と「スキル（Skills）」の概念が明確に分離されていることが鍵となります。

- **ツール (Tools)**: `read_file`, `shell_command`, `web_search` など、エージェントが外部環境に干渉するための**関数・API（手足）**。
- **スキル (Skills)**: [SKILL.md](file:///home/heppo/.gemini/antigravity/skills/skill-creator/SKILL.md) や関連スクリプトで構成される、特定のタスクをどう解決するかの**手続き的知識・ワークフロー（脳の拡張マニュアル）**。

この違いを踏まえると、OpenClawとGemini CLIの間で**「無理にツールスキーマやスキルフォルダを同期・プロキシする必要はない」**という結論に至ります。

### 最適なアーキテクチャ：完全な疎結合（役割分担）
アダプタ構成は「不可能な領域」を生むのではなく、むしろ最もクリーンな役割分担を実現します。

1. **OpenClaw（Gateway / Cron層）**
   - 役割: Telegram/WhatsApp等の外部メッセンジャーとの通信、[HeartbeatRunner](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/openclaw/src/infra/heartbeat-runner.ts#117-121) による定期的起床とスケジューリング。
   - 動作: イベント（ユーザーメッセージやHeartbeat）が発生したら、**「何が起きたか」というテキストだけ**をまとめ、ローカルAPI（アダプタ）経由でGemini CLIに丸投げする。
2. **Gemini CLI（推論 / 実行層）**
   - 役割: プロンプトの解釈、計画立案、ツールの実行、スキルのロード。
   - 動作: アダプタからリクエストを受けると、**Gemini CLI自身がネイティブに持つ強力なツール（Google-native tools）と、`~/.gemini/skills/` に配置されたスキル**を自律的にロード・駆使してタスクを解決し、最終的な結果テキストのみを返す。

この設計であれば、OpenClaw側のスキルやツールをGemini CLIに無理に翻訳する必要はありません。Gemini CLIはGemini CLIの作法でタスクをこなし、OpenClawは単なる「インターフェース・トリガー」として機能します。

## 2. スキルフォルダの「同期」の難しさ
OpenClawの「スキル」とGemini CLIの「ツール」は、単なるプロンプトや定義ファイルではなく、それぞれの固有のNode.jsランタイム（`OpenClawConfig` や Geminiの [Config](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/gemini-cli/packages/core/src/agents/generalist-agent.ts#49-55), `MessageBus`）に深く依存したTypeScriptコードです。
  - **不可能な領域**: 「フォルダを同期させる」だけでは互換性がなく全く動きません。OpenClaw用に書かれたスキルをGemini CLI（またはMCPサーバー）上で動かすには、コードレベルでの「翻訳（トランスパイル）」やアダプタ層でのモックオブジェクト（仮想的な依存注入）の提供が必要になり、完全な自動同期は技術的にほぼ不可能です。

## 2. アダプタ構成における課題（セッション・コンテキストの管理）
OpenClawは `.openclaw/sessions/` に独自の形式で詳細な会話履歴（システムメタデータやHeartbeatの軌跡を含む）を管理しています。一方、Gemini CLIは `~/.gemini/` のDB・セッションファイルで状態を管理します。
アダプタがAPIリクエストを受けた際、OpenClawから送られてくる大量の「過去のメッセージ配列」をどのように扱うかが問題になります。
- 全履歴をGemini CLIに食わせる（ステートレスAPIとして扱う）場合、Gemini CLI側の高度なセッション管理機能やReplay機能が死にます。
- 実質的に「脳」が2つある状態になり、どちらの履歴を正とすべきかの競合（Desync）が発生しやすくなります。

### 追記：`cli-agent-summoner` のアプローチを導入した場合の評価
ユーザー提案にある「`cli-agent-summoner`内にある `gemini --resume <session_id>` を使ってセッションをCLIネイティブ側に任せる」コードをアダプタに組み込んだ場合、「APIリクエストごとの履歴送信の無駄」は解決します。
しかし、OpenClaw特有の**「永続的な自律稼働（Heartbeat）」と決定的に相性が悪い**という新たな問題が発生します。

- **文脈の肥大化とPruningの不一致**: 
  OpenClawはシステム設計上、数十時間稼働し続けます。何もない時は `HEARTBEAT_OK` とだけ返し、直後にOpenClaw本体がそのログ（無駄なターン）をファイルから削除（Prune）することでコンテキストの枯渇を防ぎます。
  しかし、Gemini CLIの `--resume` に履歴を委ねると、Gemini側の内部DBには `HEARTBEAT_OK` のターンが永遠に蓄積され続け、数日でトークン上限に達します。

### 解決策: ステートレスなアダプタAPIの構築
セッション問題の最も綺麗な解決策は、 **「Gemini CLI側の永続セッション（--resume）を使わず、アダプタを完全にステートレスなローカルAPIとして動作させる」** ことです。
- OpenClawが独自に管理・Pruneした綺麗で最小化された「過去の会話履歴メッセージ配列」を、毎回アダプタにHTTP POSTする。
- アダプタは受け取ったメッセージ配列をGemini CLIの内部ライブラリ機能に直接流し込み（一時的なセッションとして構築）、一度のレスポンスを生成して返す。
これにより、「脳の競合」も「Heartbeatログの肥大化」も完全に防げます。

---

## 結論：アダプタ構成は実現かつ最適解である
スキルとツールの概念の違いと役割分担を整理したことで、ご提案のアダプタ構成が「不可能」ではなく、むしろ**「双方の長所を活かした保守性の高い最適解」**であることが明確になりました。

OpenClawの [runCliAgent](file:///home/heppo/.gemini/antigravity/playground/emerald-copernicus/openclaw/src/agents/cli-runner.ts#35-359) または `pi-embedded-runner` の呼び出し先を、今回作成する「Local Node.js アダプタAPI」に向けることで、OpenClaw特有の自立稼働システムをそのまま活かしつつ、中身の推論とハンズオン（ツール実行）はすべて強力なGemini CLIに任せる仕組みが実現できます。
